# ConfigMaps in Helm

ConfigMap allows to transfer the files data to containers, so we can "easily" pass some not large files and do not include them inside image (e.g. configuration files).

Inside the [ConfigMap manifest](./chart-msc-time/templates/configmap.yaml) I retranslated the content of [config file](./chart-msc-time/files/app_config.json) as a content for volume. Then, I mounted that data for containers with `volumeMounts` in [deployment.yaml](./chart-msc-time/templates/deployment.yaml).

### Result:
```sh
# Get created pods
$ kubectl get po
NAME                           READY   STATUS        RESTARTS   AGE
msc-time-py-54f755498c-g22ww   1/1     Running       0          34s
msc-time-py-54f755498c-qfzbq   1/1     Running       0          36s
msc-time-py-54f755498c-vgjjt   1/1     Running       0          40s

# View files in /app folder, config.json file should be here
$ kubectl exec msc-time-py-54f755498c-g22ww -- ls -l /app
total 12
-rw-r--r--    1 root     root            80 Nov 20 23:07 config.json
-rwxr-xr-x    1 root     root          1259 Oct 30 15:52 main.py
-rwxr-xr-x    1 root     root            53 Oct 30 15:52 requirements.txt

# File is in place, let's read it
$ kubectl exec msc-time-py-54f755498c-g22ww -- cat config.json
{
    "version": "Hello World",
    "history_text": "Records of time accesses"
}
```

That's it! ðŸ˜„ðŸ”«

## Bonus: StatefulSet, Headless service, Persistent Volumes
**StatefulSet** is similar to Deployment - it allows to manage pods, but unlike the Deployment can manage uniqueness of pods and capable to work with different application states on different machines.

**Headless service** is a cluster with `None` cluster IP, so we do not expose service with build-in k8s mechanisms but (probably) by external discovery tools (or do not expose it at all)

**PersistentVolumes** is similar to Docker volume - it is a common storage that is available for all pods where each of them can store files