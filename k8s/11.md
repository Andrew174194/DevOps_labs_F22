## Secrets

### Secret by `kubectl`

Create a secret by `kubectl` command:
```sh
$ kubectl create secret generic secret-key --from-literal=token=s0mETokeN
secret/secret-key created
```

As a result of saved secret, we can use the followings commands:
```sh 
$ kubectl get secrets  # write all existing secrets           
NAME                            TYPE                 DATA   AGE  
secret-key                      Opaque               1      3m12s
```

```sh
$ kubectl describe secret secret-key  # write information about particular secret
Name:         secret-key
Namespace:    default   
Labels:       <none>    
Annotations:  <none>    

Type:  Opaque

Data
====
token:  9 bytes
```

```sh
$ kubectl get secret secret-key -o jsonpath={.data.token} # get encoded value of secret-key.token
{"token":"czBtRVRva2VO"}
$ echo 'czBtRVRva2VO' | base64 --decode # decode the value
s0mETokeN
```

As we can see, the secret is saved, it's value is encoded within the system, and has correct decoded value

### Secret with Helm's `secrets.yaml`

Let me create the environment variable for particular Helm cluster. For this puropses I define encoded to `base64` secret token inside the [secrets.yaml](./chart-msc-time/templates/secrets.yaml) and include it into a cluster with `spec.template.spec.containers.env` property in [deployment.yaml](./chart-msc-time/templates/deployment.yaml).

As a result, the presence of variable inside the Helm cluster containers can be checked by the part of output of the following command:
```sh
$ kubectl describe pod
Name:             msc-time-py-554db79d97-rdqjz
...
    Limits:
      cpu:     200m
      memory:  256M
    Requests:
      cpu:      100m
      memory:   64M
...

Name:             msc-time-py-554db79d97-tsxp2
...
    Limits:
      cpu:     200m
      memory:  256M
    Requests:
      cpu:      100m
      memory:   64M
...

Name:             msc-time-py-554db79d97-xfpzt
...
    Limits:
      cpu:     200m
      memory:  256M
    Requests:
      cpu:      100m
      memory:   64M
...
```